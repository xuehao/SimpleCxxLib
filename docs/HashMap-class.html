<html>
<head>
<title>HashMap&lt;KeyType,ValueType&gt;</title>
<link rel="stylesheet" type="text/css" href="cppdoc.css" />
<link rel="shortcut icon" href="images/favicon.png">
</head>
<body>
<h1>The <code><a href=".">SimpleCxxLib</a></code> package</h1>
<hr>
<div class=include>#include "hashmap.h"</div>
<h1 class=header><code>class HashMap&lt;KeyType,ValueType&gt;</code></h1>
This class implements an efficient association between
<b><i>keys</i></b> and <b><i>values</i></b>.  This class is
identical to the <a href="Map-class.html"><code>Map</code></a> class
except for the fact that it uses a hash table as its underlying
representation.  Although the <code>HashMap</code> class operates in
constant time, the iterator for <code>HashMap</code> returns the
values in a seemingly random order.
<table class=index width=100%>
<tr><td class=indexHead colspan=2>Constructor</td></tr>
<tr><td class=indexKey><nobr><a href="#Constructor:HashMap">HashMap()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Initializes a new empty map that associates keys and values of the specified types.</td></tr>
<tr><td class=indexHead colspan=2>Methods</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:clear">clear()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Removes all entries from this map.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:containsKey">containsKey(key)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns <code>true</code> if there is an entry for <code>key</code> in this map.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:get">get(key)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns the value associated with <code>key</code> in this map.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:isEmpty">isEmpty()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns <code>true</code> if this map contains no entries.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:mapAll">mapAll(fn)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Iterates through the map entries and calls <code>fn(key, value)</code> for each one.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:put">put(key,&nbsp;value)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Associates <code>key</code> with <code>value</code> in this map.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:remove">remove(key)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Removes any entry for <code>key</code> from this map.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:size">size()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns the number of entries in this map.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:toString">toString()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Converts the map to a printable string representation.</td></tr>
<tr><td class=indexHead colspan=2>Operator</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:[]">map[key]</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Selects the value associated with <code>key</code>.</td></tr>
</table>
<h2>Constructor detail</h2>
<hr>
<a name="Constructor:HashMap"></a>
<pre class=detailCode>
HashMap();
</pre>
<div class=detailHTML>
Initializes a new empty map that associates keys and values of
the specified types.  The type used for the key must define
the <code>==</code> operator, and there must be a free function
with the following signature:

<pre>
   int hashCode(KeyType key);
</pre>

that returns a positive integer determined by the key.  This interface
exports <code>hashCode</code> functions for <code>string</code> and
the C++ primitive types.
<p>Usage:<br>
</div>
<pre class=usageCode>
HashMap&lt;KeyType,ValueType&gt; map;
HashMap&lt;KeyType,ValueType&gt; map = {{ k1, v1}, { k2, v2 }};
</pre>
<hr>
</table>
<h2>Method detail</h2>
<hr>
<a name="Method:size"></a>
<pre class=detailCode>
int size() const;
</pre>
<div class=detailHTML>
Returns the number of entries in this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
int nEntries = map.size();
</pre>
<hr>
<a name="Method:isEmpty"></a>
<pre class=detailCode>
bool isEmpty() const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if this map contains no entries.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (map.isEmpty()) ...
</pre>
<hr>
<a name="Method:put"></a>
<pre class=detailCode>
void put(KeyType key, ValueType value);
</pre>
<div class=detailHTML>
Associates <code>key</code> with <code>value</code> in this map.
Any previous value associated with <code>key</code> is replaced
by the new value.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.put(key, value);
</pre>
<hr>
<a name="Method:get"></a>
<pre class=detailCode>
ValueType get(KeyType key) const;
</pre>
<div class=detailHTML>
Returns the value associated with <code>key</code> in this map.
If <code>key</code> is not found, <code>get</code> returns the
default value for <code>ValueType</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
ValueType value = map.get(key);
</pre>
<hr>
<a name="Method:containsKey"></a>
<pre class=detailCode>
bool containsKey(KeyType key) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if there is an entry for <code>key</code>
in this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (map.containsKey(key)) ...
</pre>
<hr>
<a name="Method:remove"></a>
<pre class=detailCode>
void remove(KeyType key);
</pre>
<div class=detailHTML>
Removes any entry for <code>key</code> from this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.remove(key);
</pre>
<hr>
<a name="Method:clear"></a>
<pre class=detailCode>
void clear();
</pre>
<div class=detailHTML>
Removes all entries from this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.clear();
</pre>
<hr>
<a name="Method:toString"></a>
<pre class=detailCode>
string toString();
</pre>
<div class=detailHTML>
Converts the map to a printable string representation.
<p>Usage:<br>
</div>
<pre class=usageCode>
string str = map.toString();
</pre>
<hr>
<a name="Method:mapAll"></a>
<pre class=detailCode>
void mapAll(void (*fn)(KeyType, ValueType)) const;
void mapAll(void (*fn)(const KeyType &amp;, const ValueType &amp;)) const;
void mapAll(FunctorType fn) const;
</pre>
<div class=detailHTML>
Iterates through the map entries and calls <code>fn(key, value)</code>
for each one.  The keys are processed in an undetermined order.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.mapAll(fn);
</pre>
<hr>
</table>
<h2>Operator detail</h2>
<hr>
<a name="Operator:[]"></a>
<pre class=detailCode>
ValueType &amp; operator[](KeyType key);
ValueType operator[](KeyType key) const;
</pre>
<div class=detailHTML>
Selects the value associated with <code>key</code>.  This syntax
makes it easy to think of a map as an "associative array"
indexed by the key type.  If <code>key</code> is already present
in the map, this function returns a reference to its associated
value.  If key is not present in the map, a new entry is created
whose value is set to the default for the value type.
<p>Usage:<br>
</div>
<pre class=usageCode>
map[key]
</pre>
<hr>
</table>
</body>
</html>
